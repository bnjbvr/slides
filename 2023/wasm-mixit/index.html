<!DOCTYPE html>
<html>
  <head>
    <title>√âtat de WebAssembly en 2023</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">

      @import url(https://fonts.googleapis.com/css?family=Zilla+Slab);
      @import url(https://fonts.googleapis.com/css?family=Roboto);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono);

      .remark-slide-content {
          background-color: #e5f2f5;
          font-size: 2.2rem;
      }

      body {
          font-family: 'Roboto', serif;
          color: #187aa4;
      }

      h1, h2, h3 {
          font-family: 'Zilla Slab', sans-serif;
          font-weight: normal;
      }

      h1 {
          color: #05445e;
      }

      a {
          text-decoration: none;
          color: #38bad4;
      }

      .white-bg, .white-bg h1 {
          background-color: white;
          color: black;
      }

      .black-bg, .black-bg h1 {
          background-color: black;
          color: white;
      }

      .black-bg a {
          color: #3abce6;
      }

      blockquote {
          font-style: italic;
          font-size: 1.2em;
      }
      blockquote strong {
          color: #189ab4;
      }

      .remark-code, .remark-inline-code {
          font-family: 'Ubuntu Mono';
          font-size: 1.2em;
      }

      .intro img {
          height: 6rem;
          margin-right: 1em;
      }

      .smaller {
          font-size: 1.8rem;
      }
      .much-smaller {
          font-size: 1.3rem;
      }

      .smaller .remark-code {
          font-size: 1.8rem;
      }
    </style>
  </head>
  <body>
    <textarea id="source" rows="100%" cols="100%">
class: center, middle

# WebAssembly en 2023

---
class: intro, black-bg, center, middle

# Qui suis-je ?

![Ma t√™te en d√©guisement de mariage](../../img/moi.jpg)
![Logo de mozilla](../../img/mozilla.png)
![Logo d'Embark Studios](../../img/embark.png)

???

- d√©veloppeur depuis trop longtemps
- impl de wasm dans Firefox, puis wasmtime
- utilisateur de wasm chez Embark Studios
- un pied dans le dev web avec Kresus

---

# Sommaire

- Sommaire (‚¨Ö vous √™tes ici)
- C'est quoi d√©j√† WebAssembly ? ü§î
- Cas d'utilisation üëÄ
- Les √©volutions du langage üìà
    - WASI üìÇ
    - Component Model üß±

???

- Si on arrive √† avoir du temps pour les questions r√©ponses ce sera un miracle.

---

# WebAssembly c'est quoi ?

- Un format binaire (*bytecode*)
- *Cible de compilation*
- Un environnement d'ex√©cution
- Standardis√© de mani√®re ouverte

???

- .wasm, compact
- Programmes g√©n√©r√©s par des compilateurs
- CPU ne parle pas wasm, donc ex√©cution
- Navigateurs d'abord, puis standard W3C, depuis 2019

---

# Cours d'histoire

- 2015 : annonce
- Mars 2017 : version 1.0, "MVP"
- D√©cembre 2019 : recommendation W3C
- Avril 2022 : version 2.0 (draft W3C)

---
background-image: url(../../img/compilation.png)
background-size: 100% auto

# Comment √ßa marche‚ÄØ?

???

- Plein de langages qui compilent vers WASM
- Portable

---

# √áa fait quoi‚ÄØ?

- Op√©rations arithm√©tiques (i32/i64, f32/64), li√©es √† la m√©moire, etc.
- Poss√®de son propre bloc de m√©moire
- *Auto-contenu* : imports / exports

???

- M√©moire partag√© avec le reste du monde
- imports = fonctions qui proviennent de l'h√¥te
- exports = fonctions fournies au monde ext√©rieur

---

# Propri√©t√©s

- Rapide √† l'*ex√©cution*
- Rapide √† l'*instantiation*
- S√©curis√© (*sandbox*)
- Portable

???

- 20% plus lent que du code natif, si les fonctionnalit√©s utilis√©es par le programme natif sont √©galement disponibles dans wasm
- instantation rapide car juste "traduction"
- "sandbox√©", ne sait rien faire par d√©faut
- compil√© une fois, tourne partout ensuite

---
class: center, middle

# Cas d'usages

---

# **Web**(Assembly)

- Hot code
- Partage de code m√©tier
- Portage d'app compl√®te
- Le code front dans votre langage favori

???

- cryptographie
- players Disney+ / Netflix
- Photoshop / jeux vid√©os
- Blazor en C#, yew en Rust, etc.

---

# Virtualisation

> Faire tourner le code de quelqu'un d'autre, de mani√®re s√©curis√©e et rapide

???

- √©viter les exploits
- √©viter les supply chain attacks

---

# Virtualisation

- Architecture de plugins
- Containers tr√®s l√©gers
    - VM üê¢
    - container üöó
    - wasm üöÄ
- Architectures cloud
    - Dev ops
    - FaaS
    - Serverless / Edge computing

???
- architecture de plugins (e.g. moteur de jeu Ambiant, Trinity)
    - sandboxing + rapide + polyglotte
- containers tr√®s l√©gers
    - VM = virtualisation du mat√©riel, de l'OS et de tous les logiciels
    - container = virtualisation de l'OS et des logiciels
    - wasm = virtualisation d'un logiciel par module wasm
        - *nano-processes*
    - e.g. Docker wasm runtime, nodes wasm dans Kubernetes avec Krustlet
    - temps de d√©marrage : minutes vs 2 millisecondes vs 5 microsecondes
- architectures cloud
    - plateforme cloud applicative (√† la heroku)
    - function as a service / lambdas (e.g. Shopify Functions)
    - edge computing (e.g. Fastly / Cloudflare)
    - petite r√©volution !

---

# Quoi de neuf depuis le MVP‚ÄØ?

- SIMD (phase 4)
- Tail calls (phase 4)
- Atomics / shared memory (phase 3)
- Garbage collector (phase 3)

???

- SIMD (adopt√© dans le standard depuis 2021, v2)
    - traitement du signal / audio / video
    - TensorFlow dans le navigateur, e.g. [virtual backgrounds dans GMeet](https://ai.googleblog.com/2020/10/background-features-in-google-meet.html)
- Tail calls (phase 4)
    - n√©cessaire pour les langages fonctionnels comme Lisp / Scheme
- Atomics / shared memory (phase 3)
    - multithreading dans le programme wasm
    - pas encore de capacit√© √† cr√©er de nouveaux threads
- Nouveaut√© : Garbage collector
    - phase 3
    - permet de d√©finir des structures / tableaux g√©r√©s par un *garbage collector*
    - tr√®s important pour le support de tous les langages √† GC !
        - √©vite des hacks pour supporter les GCs
        - meilleures performances

---

# WA‚ÄØSystem‚ÄØInterface‚ÄØ(WASI)

- Standardiser les APIs d'une interface syst√®me
    - I/O, file system, network, random...
- *Ensemble* de sp√©cifications
    - d√©finies it√©rativement (*preview0*)
- Syst√®me de *permissions*
    - Aucune, par d√©faut‚ÄØ!

???

- Standardiser les APIs d'une interface syst√®me
    - on avait d√©j√† le *code* portable, on a besoin maintenant d'un environnement (h√¥te) portable !
- Donne acc√®s au monde ext√©rieur (syst√®me de fichiers, r√©seau, )
    - via des *capabilities* (permissions)
    - e.g. pas acc√®s √† tous les fichiers et r√©pertoires, mais √† rien par d√©faut (principle of least authority), et on allowlist uniquement ce qui est n√©cessaire
- Un *ensemble* de nouvelles sp√©cifications
- Plusieurs versions diff√©rentes, pas de r√©trocompatibilit√© (relativement stable, mais d√©sir
  d'exp√©rimenter)
- Preview 1
    - reprend principalement les concepts de Posix tels quels
    - inspir√© par CloudABI
    - interface √† base de pointeurs et d'entiers

---
class: smaller

# Interface √† base d'entiers‚ÄØü•¥

```lisp
(function $__wasi_path_remove_directory
    (result i32)
    (param i32 i32)
)
```

```c
__wasi_errno_t
    __wasi_path_remove_directory(
        __wasi_fd_t dirfd,
        const char* path
    );
```

---
class: smaller

# Interface haut niveau

```python
class WasiDir:
    def remove_in_dir(self, path):
        err = __wasi_path_remove_directory(
            self.dirfd, path)
        if err != 0:
            raise RemoveDirException(...)

my_dir = WasiDir(...)
my_dir.remove_in_dir("sub_directory")
```

???

- code "bas niveau", proche du wasm, en C
- code "haut niveau", qui va correspond, en Python

---
class: smaller

### Pause citation

> If WASM+WASI existed in 2008, we wouldn't have needed to created Docker. That's how important it is. Webassembly on the server is the future of computing. A standardized system interface was the missing link.

--

- Solomon Hykes, Docker co-founder (mars 2019)

???

Mais de qui est cette citation‚ÄØ?

---

# Component model

> Comment promouvoir la *composabilit√©* des programmes, tout en maintenant la s√©curit√© et les performances‚ÄØ?

???

- prendre des fonctionnalit√©s d√©j√† impl√©ment√©es et les faire fonctionner ensemble pour cr√©er de nouveaux usages
- vous avez un programme pour lire des slides
- vous avez un programme de serveur Web
- comment faire un programme pour parcourir des slides sur le Web‚ÄØ?

---

# modules wasm = composants

- s'interfacent les uns avec les autres
- se passent des donn√©es de types haut-niveau
- *importent* d'autres composants, *exportent* des m√©thodes
- *cr√©ent* des nouveaux composants au moment de l'instantiation

???

- Id√©e = des modules wasm qui agissent comme des *composants*, petites briques lego
    - √©crits dans des langages diff√©rents
    - s'interfacent les uns avec les autres
    - se passent des donn√©es avec des types haut-niveau d√©finis par les devs
- Un composant d√©finit un ensemble d'exports (APIs fournies au reste du monde) et un ensemble d'imports (APIs dont il a besoin pour fonctionner)
    - sous la forme d'autres composants üß†
    - qui peuvent √™tre impl√©ment√©s par l'h√¥te (runtime) ou par d'autres composants
        - injection de d√©pendences / testing
- Un composant peut aussi cr√©er de nouveaux composants au moment de son instantiation, *tant qu'ils leur passent les d√©pendences requises*

---

# Types de haut niveau

- WIT = *WebAssembly Interface Types*
    - Structures, tableaux,...
    - G√©n√©rateurs de *bindings*
- Des ressources et des *handles*
    - Ressource maintenue par un module et r√©f√©rences (*handle*) vers cette ressource
- Programmation concurrente structur√©e
    - Runtime *async* unifi√©

???

- Types de haut niveau
    - D√©finition de types avec un langage con√ßu pour cela : WIT = WebAssembly Interface Types
        - structures, tableaux, options, r√©sultats, etc.
        - des programmes g√©n√®rent des *bindings* qui transforment ces types haut-niveau en les types bas-niveau que wasm core sait manipuler
        - les composants peuvent r√©utiliser ce langage pour d√©finir leurs *interfaces* et avoir un langage commun
            - plus besoin de glue code
    - Ressources
        - *Everything is a file* = abstraction trop g√©n√©rale
        - Si j'importe un file-system, qu'est-ce que j'utilise en r√©alit√© ? audit compliqu√©
        - √Ä la place, ressources / handles
            - ressources identifi√©es uniquement par les composants qui les c√®dent (impossible de se tromper)
            - des types simples que les fonctions peuvent manipuler
            - toujours le syst√®me de permissions
    - Programmation concurrente structur√©e
        - Une mani√®re pour diff√©rents langages / runtimes d'utiliser les m√™mes primitives de programmation concurrente
            - = async/await entre Rust via tokio / NodeJS via libuv / Python via asyncio
        - Top pour les performances √©galement !

---
class: smaller

# Exemple de WIT

```
interface slide-manager {
  record slide {
    content: string,
    index: u32,
  }
  add-slide: func(s: slide)
  move-to-slide: func(i32)
  get-current: func() -> slide
}

default world pouvoirpoint {
  import print: func(msg: string)
  import keyboard: self.keyboard-events
  import slides: self.slide-manager
  export run: func()
}
```

---

# La vision du Component Model

- Composabilit√©: interfaces
- Performance: ABI commune
- S√©curit√© : permissions

--
- Disponible d√©s maintenant !

???

- La vision : un mod√®le unifi√© du concept de d√©pendences
    - Tous les langages qui arrivent √† se parler main dans la main (composabilit√©)
    - une ABI commune pour les gouverner toutes (performance)
    - s√©curit√© bas√©e sur le principe de *capabilities* (permissions)
- Disponible d√©s maintenant car construit au-dessus de Wasm "core"

---

# [O√π en-est on ?](https://bytecodealliance.org/articles/component-model-tooling-compatibility)

- **Instable** : en cours de sp√©cification
- WASI preview 2 r√©√©crit en termes du *component model*
    - bindings gratuits avec WIT ü•≥
    - nouvelles interfaces : blob store, KV store, logging, http, grpc, sql...
- Support runtime : **wasmtime, polyfill Web**
- G√©n√©rateurs de *bindings* WIT‚ÄØ: **wasmtime, C/Go/Rust/Java**
- Cr√©ateurs de *composants* : Rust, JS

???

- [O√π en-est on ?](https://bytecodealliance.org/articles/component-model-tooling-compatibility)
    - Toujours en cours de sp√©cification, relativement instable
    - WASI preview 2 r√©√©crit en termes du *component model*
        - des interfaces plus haut niveau : Key/Value store, logging, http, grpc, sql, threads, etc.
    - Runtime : wasmtime
    - G√©n√©rateurs de *bindings* pour WIT : wasmtime (h√¥te), C/Go/Rust/Java (guest)
    - G√©n√©rateurs de *composants* : cargo-component (Rust), jco (JavaScript)

---

# Dans un lointain tur-fu üëÄ

- Unique syst√®me de d√©pendences
    - *Jourdain*, d√©veloppeur.se wasm

--
- Cr√©er un langage ~= √©mettre du wasm‚ÄØ?

???

- Turfu
    - ex√©cuter du wasm sans s'en rendre compte ?
    - un syst√®me de d√©pendences unifi√©es entre tous les langages
        - utiliser du code de n'importe quel langage depuis n'importe quel langage
        - ne pas se soucier du probl√®me d'attaques de cha√Æne logistique
    - cr√©er un langage de programmation ~= √©crire un langage qui compile vers wasm

---

# 2 (r)√©volutions √† retenir

- Virtualisation via wasm, dans le cloud computing
- Des composants (d√©pendences) unifi√©s via le *component model*

---
class: smaller

# Merci !

Si vous n'avez pas de questions,

c'est √† moi qu'il faut les poser,

et si vous voulez mon opinion,

√ßa je peux aller vous la chercher üéµ

- **bnjbvr** sur üêò / üê¶ / üï∏

---
class: middle, center

# Annexe : la mort de JS‚ÄØ?

???

- oui, en tant que *cible de compilation*
- non, en tant que *langage*

---
class: middle, center

# Annexe : Java 2.0‚ÄØ?

???

- Wasm est int√©gr√© dans la plateforme Web par d√©faut (Java = plugin)
- Le fait que d'autres langages tournent sur la JVM est plut√¥t accidentel
    - e.g *invoke-dynamic*
- Le bytecode de la JVM a √©t√© con√ßu pour faire tourner Java
- On n'√©chappe pas au GC !
- Comme pas con√ßu pour, les autres langages ne tournent pas efficacement sur la JVM

---
class: much-smaller

# Annexe : Support des langages

- Langage cr√©√©s uniquement pour la compilation vers wasm
    - [Grain](https://grain-lang.org/)
- Compil√©s
    - Rust, C, C++: tier 1
    - Go: support natif, TInyGo
- JVM:
    - Java, plusieurs approches:
        - compiler le bytecode vers du wasm: TeaVM
        - interpr√©teur du bytecode compil√© vers wasm: DoppioJVM
    - Kotlin: Kotlin Wasm experimental target in Kotlin 1.8.20 (direct translation)
- Interpreted languages = on compile la VM dans un module Wasm
    - Lua
    - JavaScript
        - QuickJS via [Javy](https://github.com/Shopify/javy) / Spidermonkey
    - Python / PHP / Ruby:‚ÄØinterpreting the programs via compiling their interpreters to wasm
        - cf https://wasmlabs.dev/articles/webassembly-language-runtimes-march-2023/

    </textarea>
    <script src="remark.js">
    </script>
    <script>
var slideshow = remark.create({
    highlightLanguage: "javascript",
    highlightLines: true,
    countIncrementalSlides: false
});
    </script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
  </body>
</html>
