<!DOCTYPE html>
<html>
  <head>
    <title>Faciliter le d√©veloppement d'applications web rapides avec WebAssembly</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">

      @import url(https://fonts.googleapis.com/css?family=Zilla+Slab);
      @import url(https://fonts.googleapis.com/css?family=Roboto);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono);

      .remark-slide-content {
          background-color: #0d47a1;
      }

      body {
          font-family: 'Roboto', serif;
          color: #e8eaf6;
      }

      h1, h2, h3 {
          font-family: 'Zilla Slab', sans-serif;
          font-weight: normal;
      }

      h1 {
          color: #f86728;
      }

      a {
          text-decoration: none;
          color: #fbab6c;
      }

      .white-bg, .white-bg h1 {
          background-color: white;
          color: black;
      }

      blockquote {
          font-style: italic;
          font-size: 1.2em;
      }
      blockquote strong {
          color: #f86728;
      }

      .remark-code, .remark-inline-code {
          font-family: 'Ubuntu Mono';
          font-size: 1.2em;
      }

      .bigger {
          font-size: 1.8em;
      }
      .bigger img {
          height: 10em;
      }
      .bigger .remark-slide-number {
          font-size: 20px;
      }

    </style>
  </head>
  <body>
    <textarea id="source" rows="100%" cols="100%">

class: center, middle

# Des applications Web rapides avec WebAssembly

### ou comment utiliser [votre langage] sur le Web !

???

Notes de celui qui parle. Si vous voyez cela, il y a un rat√© quelque part.

---

background-image: url(./img/firefox.png)
background-size: 50% auto

# [@bnjbvr](https://twitter.com/bnjbvr)

.left[such [floss](https://framasoft.org)]

.right[very [mozilla](https://mozilla.org)]

.left[so [kresus](https://kresus.org)]

.bigger.right[wow]

???

Je suis ing√©nieur logiciel, travaille pour mozilla sur la VM commune √† JS et √†
WebAssembly, etc.

---

class: middle, center

# Deux gros probl√®mes du Web ?

![First world problems](./img/firstworldproblem.jpg)

---

# Les performances

<blockquote>
<p>Loading time is a major factor in page abandonment and loyalty; 53% of users
report that they abandon sites that take <strong>more than three seconds to
load</strong> (source: SOASTA Google study report).</p>

<p>Users visit more often, stay longer, search more, and buy more frequently on
sites that load quickly than on slower ones; one company found that a
conversion increase of 7% resulted from <strong>a speed improvement of as
little as .85 seconds</strong> (source: WPO Stats).</p>

<p>Slow loading is detrimental for <strong>search engine optimization
(SEO)</strong> because it can lower your site's ranking, resulting in fewer
visits, reads, and conversions; in 2018, Google will implement site speed as a
ranking signal in its mobile searches (source: Search Engine Land).</p>
</blockquote>

---

# Le langage impos√©

<blockquote class="twitter-tweet" data-conversation="none" data-lang="fr"><p lang="fr" dir="ltr">c&#39;est vraiment √ßa. On dirait le Javascript. Tout le monde en fait alors qu&#39;on sait que c&#39;est pourri.</p>&mdash; Seboss666 (@Seboss666) <a href="https://twitter.com/Seboss666/status/768819685823508481?ref_src=twsrc%5Etfw">25 ao√ªt 2016</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="fr"><p lang="fr" dir="ltr">ah tu veux dire que le javascript c&#39;est nul. en effet.</p>&mdash; Alice Voidstar (@CobaltVelvet) <a href="https://twitter.com/CobaltVelvet/status/832181927377514496?ref_src=twsrc%5Etfw">16 f√©vrier 2017</a></blockquote>

---

# Optimisation des langages dynamiques

```js
function f(a) { return a + 42; }
```

--

```js
f(1); // integer
```

--

```js
f(13.37); // floating-point
```

--

```js
f("hi there"); // string
```

--

```js
f({ valueOf() { alert('lol'); return 1; }});
// integer & side-effects
```

???

- langage dynamique => rend les optimisations plus difficiles
- inf√©rence de types + hypoth√®ses v√©rifi√©es dynamiquement
- d√©compilation, compilation, recompilation
- garbage collector -> pauses √† l'ex√©cution

D'o√π la compilation vers le web : prendre un langage de son choix, et le
compiler vers du JS √† l'aide d'un outil qui fera toutes sortes d'optimisations
pour nous.

---

class: white-bg
background-image: url(./img/logo.png)

---

class: bigger

# C'est quoi WebAssembly ?

### Un **environnement d'ex√©cution** stable, bien d√©fini, s√©curis√©, rapide comme du natif.

???

- stable = par plateforme, architecture, etc.
- bien d√©fini = le moins de comportements ind√©finis possibles

--

### Un nouveau **standard** cr√©√© en coop√©ration par Apple, Google, Microsoft et Mozilla.

???

Draft W3C depuis le 15 fevrier 2018

WG/CG (r√©union tous les mois / deux semaines)

--
### Un format **binaire** compact, portable, rapide √† charger et √† *compiler*.

--
### Tout √ßa int√©gr√© dans la plateforme Web.

???

- plus de plugins (cause de crashes, pas besoin de les mettre √† jour).
- facile √† distribuer (on √©vite les app stores sur mobile ou desktop).
- facile √† mettre √† jour, √† d√©ployer comme on veut, de faire du A/B testing.
- la s√©curit√© de la plateforme web (Content Security Policy, Subresource
Integrity, sandboxing...).

---

class: middle, center, white-bg

# Support des navigateurs

--

![Dans tous les navigateurs](./img/browsers.png)

???

A l'heure de l'√©criture, repr√©sente 71% des navigateurs selon CanIUse.

Attention support dans Safari pour iOS, activ√© puis d√©sactiv√© puis r√©activ√©.

Existence d'un polyfill dans un sous ensemble de JS (asm.js) => am√©lioration
progressive.

---

# C'est efficace ?

--

## plus rapide √† d√©marrer
## plus rapide √† s'ex√©cuter
## plus compact

???

D√©marrage : fichier binaire, pas de parsing, pas d'ex√©cution lazy, tiered
compilation, streaming compilation, mise en cache.

Ex√©cution : langage statique typ√©, correspondance directe avec le CPU, pas
d'allocation m√©moire (GC), pr√©compilation par un gros compilateur. On est
seulement √† un petit √©cart de 20% des performances natives, et √ßa n'arr√™te pas
d'√©voluer !

Compact : binaire, moins √† t√©l√©charger, moins de repr√©sentations internes en
m√©moire, moins √† stocker en m√©moire, √©conomie en bande-passante donc co√ªts
serveurs.

--

## debuggable

???

Debugable : format binaire, mais repr√©sentation textuelle pour pouvoir
inspecter le code source et le deboguer ! et source maps !

---

# Cas d'utilisation

## Porter des [programmes complets](https://www.youtube.com/watch?v=TwuIRcpeUWE)

???

Programmes complets : Unity / Unreal Engine.

--

## Porter des [libs](https://websightjs.com/index-video.html)

???

Porter des libs : OpenCV, NaCL (crypto), compression, codecs, etc.

--

## Utilisation dans des [libs](https://www.youtube.com/watch?v=qfnkDyHVJzs&feature=youtu.be&t=5880)

???

Utilisation dans des libs : React pour Fiber, Glimmer VM pour Ember, etc.

--

## Pour des [apps web](http://www.adultswim.com/etcetera/elastic-man/)

???

Utilisation dans des apps web : c'est ce qui nous int√©resse ici !

---

# Pourquoi dans une app Web ?

--

### R√©soudre une probl√©matique sp√©cifique de performances

???

Premature optimization root of all evil.

- Trouver les 20% de code qui prennent 80% du temps, avec un profiler.
- Optimiser ces 20%.
- S'il y a un autre probl√®me de performance, reprendre un profiler.

--

### Profiter d'autres langages et de leurs environnements...

???

- plus simple que d'apprendre un nouveau langage, transfert de connaissances
- paradigmes diff√©rents de ceux dans JS
- possibilit√© de profiter du tooling (IDEs, etc.)

--

### ... tout en profitant de la plateforme Web

???

- int√©gration avec la plateforme Web
- source maps : montre le code source du langage utilis√© directement dans le
debugger.
- profiler

---

class: bigger

# Ces langages qui compilent vers wasm

- C/C++ ([Emscripten](http://emscripten.org/), LLVM, CheerP)
- .NET ([Blazor](https://github.com/aspnet/blazor))
- Go
- Elixir
- Faust
- JVM (Java, Kotlin, ...)

--
- [... et tous les autres](https://github.com/appcypher/awesome-wasm-langs)

--
- Rust

---

class: middle, center

# Rust

![Rust loves JS](./img/rust_love_js.png)

(Copyright [Lin Clark](https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages))

???

- Langage bas-niveau / "syst√®me"
- Mais avec une expressivit√© haut niveau
- Tr√®s rapide (langage compil√©, typ√© statiquement)
- Vous emp√™che de faire des erreurs au moment de la compilation
- Multithread√© et safe: "fearless concurrency"

Initiative de Mozilla, mais utilisation d√©passe Moz.
Dropbox, CoreOS, Coursera, OVH, npm inc, ... et GlimmerVM dans Ember !

Exemple de langage bien support√© pour √™tre compil√© vers du WebAssembly, les
m√™mes concepts peuvent s'appliquer √† tous les langages !

---

# C++ üë£ üî´

```c++
#include <iostream>
struct Obj {
    int x;
    Obj(int x) : x(x) {}
};
void func(Obj** obj) {
    Obj tmp(42);
    *obj = &tmp;
}
int main() {
    Obj* obj;
    func(&obj);
    std::cout << obj->x << std::endl;
}
```

???

Que provoque ce code ?

---

# üë£ üî´

```bash
$ g++ main.cpp && ./a.out
> 42
```

```bash
$ g++ main.cpp -O3 && ./a.out
> 0
```

```bash
$ clang++ main.cpp -O3 && ./a.out
> -1651023112
```

???

Meme pas le bon gout de provoquer un segfault !

---

# Rust üòÖ

```rust
fn main() {
    let x: &i32;
    {
        let y = 100;
        x = &y;
    }
    println!("Hello, {}", *x);
}
```

---

# Sauv√© par le compilateur !

```
error[E0597]: `y` does not live long enough
 --> src/main.rs:5:14
  |
5 |         x = &y;
  |              ^ borrowed value does not live long enough
6 |     }
  |     - `y` dropped here while still borrowed
7 |     println!("Hello, {}", *x);
8 | }
  | - borrowed value needs to live until here

error: aborting due to previous error

For more information about this error, try
`rustc --explain E0597`.
```

---

# Lifetimes

```rust
struct Data {
    name: String
}

fn get_name(data: &'lt Data) -> &'lt str {
    &data.name
}

fn main() {
    let d = Data { name: "there".to_string() };
    println!("Hello, {}!", get_name(&d));
}
```

---

# Lifetimes

```rust
struct Data {
    name: String
}
struct Borrow<'borrowed> {
    name: &'borrowed str
}

fn borrow<'lt>(data: &'lt Data) -> Borrow<'lt> {
    Borrow { name: &data.name }
}

fn main() {
    let b: Borrow;
    {
        let d = Data { name: "you".to_string() };
        b = borrow(&d); // nope
    }
    println!("Hello, {}!", b.name);
}
```

???

Les paradigmes de gestion de m√©moire dans les langages, c'est :
- soit une gestion de la m√©moire manuelle, via des pointeurs, des mallocs, etc;
meilleur contr√¥le, performances plus pr√©dictibles mais plein de
mani√®res de se tirer des balles dans le pied.
- soit une gestion de la m√©moire automatique, via un GC : plus simple pour des
d√©butants (plus dur de faire des b√™tises), mais dur de mettre en
place certains m√©canismes (finalizers), performances moins pr√©dictibles
(pauses), overhead m√©moire √† cause des m√©ta donn√©es du GC.

=> Rust choisit une barri√®re √† l'entr√©e plus √©lev√©e (compr√©hension du concept
de lifetime, compilation plus longue), en √©change de meilleures performances et
de nombreuses erreurs de gestion de m√©moire qui sont √©vit√©es.

---

# Installer Rust

### A ne faire qu'une seule fois ‚ö†Ô∏è


```
curl https://sh.rustup.rs -sSf | sh
export PATH=$HOME/.cargo/bin:$PATH
rustup toolchain install nightly
rustup target add wasm32-unknown-unknown --toolchain nightly
```

???

Attention en t√©l√©chargeant et streamant dans sh !

---

# Commencer un projet

Initialiser le projet :

```
cargo +nightly new --lib example
```

Ajouter dans le fichier `Cargo.toml` :

```
[lib]
crate-type = ["cdylib"]
```

Build vers WebAssembly :

```
cd example
cargo +nightly build --target wasm32-unknown-unknown \
    --release
```

---

### [Simple Rust example](./example/index.html) - Rust

```rust
// A function that's defined in JS.
extern {
    fn console_log(x: u32);
}

// A function that's exported to JS.
#[no_mangle]
pub extern fn add_one(a: u32) -> u32 {
    unsafe { console_log(a) };
    a + 1
}
```

---

### [Simple Rust example](./example/index.html) - JS

```js
// ‚ö†Ô∏è mimetype application/wasm
const response = fetch('example.wasm');
(async function() {
    let { instance } = (
        await WebAssembly.instantiateStreaming(response, {
            env: {
                // Define the imported JS function.
                console_log(x) {
                    console.log(x);
                }
            }
        })
    );
    alert(instance.add_one(41)); // 42
})();
```

---

# Probl√®mes de cette approche

### Etape de *build* pas int√©gr√©e
### N√©cessit√© de toucher aux APIs WebAssembly
### Interactions avec des APIs du Web depuis le langage source ?
### Interop√©rabilit√© avec des types plus complexes (source ou Web) ?

???

Wasm fournit beaucoup d'abstractions bas niveau (table de fonctions, fonctions,
bloc de m√©moire lin√©aire), mais ne permet pas d'utiliser des types plus haut
niveau : cha√Æne de caract√®res, bool√©ens, ou types d√©finis par les devs.

Possibilit√© d'appeler des fonctions JS depuis Wasm et inversement.

N√©cessit√© de rajouter plein de d√©clarations pour pouvoir utiliser des APIs Web
depuis le langage source, pour partager des types entre les deux langages, etc.

---

class: bigger

# Exemple : cha√Ænes de caract√®res

### De JS √† Rust

- transformer cette cha√Æne dans sa repr√©sentation m√©moire *en Rust*
- mettre cette repr√©sentation en m√©moire wasm
- c√¥t√© Rust, construire une cha√Æne depuis cette repr√©sentation

--

### De Rust √† JS

Les m√™mes √©tapes... en sens inverse !

???

- pas facile pour commencer √† d√©velopper

Des probl√®mes inh√©rents √† tous les langages

- surcout memoire : la chaine est repr√©sent√©e plusieurs fois.
- surcout temps : encodage / d√©codage de la cha√Æne.
- augmente l'activit√© du GC c√¥t√© JS.

---

class: center, middle

# Et si des outils faisaient le travail pour nous ?

---

# Cr√©er des projets

```bash
# wasm-pack to simplify build process
cargo install wasm-pack
# cargo-generate for project templates
cargo install cargo-generate
# template for Web counterpart
npm install -g create-wasm-app
```

Et ensuite :

```bash
# Initialize Rust project from a rust-wasm template
cargo generate \
    --git https://github.com/rustwasm/wasm-pack-template
cd example-project
wasm-pack init --mode no-build # installs Rust dependencies
# Initialize web frontend from a wasm template
npm init wasm-app www
(cd www && npm install)
```

---

# Build & bundle

Recompiler (apr√®s le premier `wasm-pack init`):

```bash
wasm-pack init --mode no-install
```

(‚ö†Ô∏è  sera remplac√© par `wasm-pack build` dans la prochaine version)

D√©ployer le front en temps r√©el avec `webpack-dev-server` (dans `www`):

```bash
cd www && npm start
```

---

# [A simple example](./example-generate/www/dist)

```rust
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    fn alert(s: &str);
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn console_log(x: u32);
}

#[wasm_bindgen]
pub fn greet(s: &str) {
    console_log(42);
    alert(&format!("Hello, {}!", s));
}
```

```js
import * as rust from "../pkg/example-project"; // js file
rust.greet("world");
```

---

# D√©clarer un type

```rust
#[wasm_bindgen]
pub struct HelloFactory {
    name: String
}
#[wasm_bindgen]
impl HelloFactory {
    pub fn new(name: String) -> HelloFactory {
        HelloFactory { name: name }
    }
    pub fn say_hello(&self) {
        alert(&format!("Hello, {}", self.name));
    }
}
```

```js
import('./project.js').then(project => {
    let factory = project.HelloFactory.new("Benjamin");
    factory.say_hello();
    factory.free();
});
```

---

class: bigger

# Comment √ßa marche ?

- annotations dans le code langage source
- trait√©es et embarqu√©es dans le binaire wasm
- ces annotations binaires sont trait√©es par un outil externe `wasm-bindgen`
- qui g√©n√®re du code glue JS / wasm pour faciliter le passage d'un univers √†
l'autre
- les annotations embarqu√©es sont retir√©es du code binaire wasm

???

wasm-bindgen g√©n√®re du code Rust et du code JS pour interagir plus facilement
entre les deux mondes.

- le code wasm r√©sultant contient un tout petit allocateur de m√©moire pour
pouvoir passer des param√®tres (via la m√©moire wasm).
- et des wrappers Rust pour reconstruire les arguments pass√©s depuis la m√©moire
ou les valeurs retourn√©es vers la m√©moire par les fonctions.
- le code JS contient des wrappers pour simplifier le passage de valeurs dans
l'autre sens √©galement.

Au final :
- 1 fichier JS qui propose une interface similaire √† celle du code Rust
- 1 fichier wasm qui sera import√© par le module JS

Remarque : tout ce qui devait √™tre fait √† la main est bel et bien effectu√© par
les wrappers ; il y a donc un co√ªt suppl√©mentaire pour passer la barri√®re de la
FFI (dans notre exemple, m√©moire : duplication des cha√Ænes ; CPU :
encodage/d√©codage).

---

class: bigger

# Des outils g√©n√©riques

- `wasm-gc`: supprime le code mort dans le module wasm.
- `wasm-bindgen`: facilite la cr√©ation de bindings entre les langages.
- `wasm-pack`: g√®re la compilation, l'utilisation de `bindgen`, la publication sur npm.
- `wasm-snip`: remplace le code pr√©sum√© mort du module wasm par un breakpoint
logiciel.

--
- ... pas encore *enti√®rement* int√©gr√©s en une √©tape de *build* unique.

???

Approche agnostique du langage => une solution possible qui pourrait se
g√©n√©raliser.

Ce n'est que le d√©but pour ces outils !

---

class: middle, center, bigger

# [D√©mo compl√®te : un correcteur de typos](./levenshtein/dist/index.html)

\#DeepLearning \#CS301

---

class: middle, center

# [yew](https://github.com/DenisKolodin/yew)

### Framework frontend pour √©crire des apps Web en Rust

???

Quid des autres langages ?

---

class: bigger

# La JVM sur le Web : un spectre

--
- Transpiler depuis le langage source
    - Par exemple, [JSweet](https://github.com/cincheo/jsweet) transpile vers JS.
    - un tel projet par langage source et par langage cible.
--
- Compiler le bytecode de la JVM (`class` files) vers wasm + √©ventuel runtime
    - Par exemple, [TeaVM](http://teavm.org/), [CheerpJ](https://www.leaningtech.com/cheerpj/).
    - une compilation par projet.
--
- Porter une JVM vers le Web.
    - Par exemple, [Doppio](https://plasma-umass.org/doppio-demo/).
    - n'importe quel bytecode JVM, mais plus grande complexit√© ou performance moindre.

???

Support exp√©rimental de wasm dans TeaVM. Probable qu'il arrive √©galement dans
Cheerpj dans le futur.

Plein d'autres projets pour porter vers le Web : JWebAssembly, Kotlin Native,
Bytecoder, GWT...

---

class: bigger

# Le cas de TeaVM

- sous-ensemble de fonctionnalit√©s
    - pas de GC
    - pas de *runtime type information* (r√©flectivit√©)
    - d'autres limitations
--
- des extensions pour interagir avec JS.

--
- [Flavour](http://teavm.org/docs/flavour/templates.html): Framework frontend complet... utilisable en Java !

--
- des [source maps](http://teavm.org/live-examples/todomvc) pour le debugging.

---

# TeaVM wasm example

```java
package org.teavm;

import org.teavm.interop.Import;
import org.teavm.interop.Export;

public class Client {
    @Import(name="get_rhs")
    private static native int get_rhs();

    @Export(name="add")
    public static int add(int a) {
        return a + get_rhs();
    }

    public static void main(String[] args) {
    }
}
```

---

class: middle, center, bigger

# [TeaVM et wasm](http://teavm.org/live-examples/jbox2d-benchmark/)

---

# Et le futur ?

--

### garbage collector

--

### host bindings

--

### threads: atomics / shared array buffers

--

### exception handling

--

### SIMD

---

class: center, middle

# En r√©sum√©

### plus rapide √† charger
### plus rapide √† l'ex√©cution

--

### *B.Y.O.L* (Bring Your Own Langage)

---

class: middle, center

# Exp√©rimentez !

### slides : [bnjbvr.github.io/slides/2018/wasm-jug](https://bnjbvr.github.io/slides/2018/wasm-jug)
### Rust+Wasm : [github.com/rustwasm](https://github.com/rustwasm/)
### WebAssembly : [webassembly.org](https://webassembly.org/)
### Infos : [@WasmWeekly](https://twitter.com/WasmWeekly)
### [@bnjbvr](https://twitter.com/bnjbvr)

    </textarea>
    <script src="remark.js">
    </script>
    <script>
var slideshow = remark.create({
    highlightLanguage: "javascript",
    highlightLines: true,
    countIncrementalSlides: false
});
    </script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
  </body>
</html>
