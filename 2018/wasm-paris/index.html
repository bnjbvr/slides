<!DOCTYPE html>
<html>
  <head>
    <title>Faciliter le d√©veloppement d'applications web rapides avec WebAssembly</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Zilla+Slab);
      @import url(https://fonts.googleapis.com/css?family=Roboto);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono);

      :root {
          --background-color: #052dbd;
          --font-color: #2cfa80;
      }

      .remark-slide-content {
          background-color: var(--background-color);
      }

      body {
          font-family: 'Roboto', serif;
          color: var(--font-color);
      }

      h1, h2, h3 {
          font-family: 'Zilla Slab', sans-serif;
          font-weight: normal;
      }

      h1 {
          color: var(--font-color);
      }

      a {
          text-decoration: none;
          color: #c4f98a;
      }

      .white-bg, .white-bg h1 {
          background-color: white;
          color: black;
      }

      blockquote {
          font-style: italic;
          font-size: 1.2em;
      }
      blockquote strong {
          color: var(--font-color);
      }

      .remark-code, .remark-inline-code {
          font-family: 'Ubuntu Mono';
          font-size: 1.2em;
      }

      .bigger {
          font-size: 1.8em;
      }
      .bigger img {
          height: 10em;
      }
      .bigger .remark-slide-number {
          font-size: 20px;
      }

    </style>
  </head>
  <body>
    <textarea id="source" rows="100%" cols="100%">

class: center, middle

# Comment compiler vers le Web

### par l'exemple de Rust

???

Notes de celui qui parle. Si vous voyez cela, il y a un rat√© quelque part.

---

background-image: url(./img/firefox.png)
background-size: 50% auto

# [@bnjbvr](https://twitter.com/bnjbvr)

.left[such [floss](https://framasoft.org)]

.right[very [mozilla](https://mozilla.org)]

.left[so [kresus](https://kresus.org)]

.bigger.right[wow]

???

Je suis ing√©nieur logiciel, travaille pour mozilla sur la VM commune √† JS et √†
WebAssembly, etc.

---

class: bigger

# Le probl√®me

### Est-ce que je peux compiler [mon langage favori] vers WebAssembly ?

--
### Quelles sont les √©tapes avant de pouvoir utiliser [mon langage favori] sur le Web ?

---

# Une proposition de r√©ponse

### Pour des libs

- Compiler le langage simplement
- G√©n√©rer des *bindings* simplement

--

### Pour des apps web

- G√©n√©rer des correspondances pour les APIs du Web
- Cr√©er des frameworks Web bas√©s sur le langage

--

### En parall√®le

- Pouvoir compiler le langage **efficacement**
- Un environnement de d√©veloppement int√©gr√©
- Des outils de debug int√©gr√©s

---

class: middle, center

# Rust

![Rust loves JS](./img/rust_love_js.png)

(Copyright [Lin Clark](https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages))

???

- Langage bas-niveau / "syst√®me"
- Mais avec une expressivit√© haut niveau
- Tr√®s rapide (langage compil√©, typ√© statiquement)
- Vous emp√™che de faire des erreurs au moment de la compilation
- Multithread√© et safe: "fearless concurrency"

Initiative de Mozilla, mais utilisation d√©passe Moz.
Dropbox, CoreOS, Coursera, OVH, npm inc, ... et GlimmerVM dans Ember !

Exemple de langage bien support√© pour √™tre compil√© vers du WebAssembly, les
m√™mes concepts peuvent s'appliquer √† tous les langages !

---

# C++ üë£ üî´

```c++
#include <iostream>
struct Obj {
    int x;
    Obj(int x) : x(x) {}
};
void func(Obj** obj) {
    Obj tmp(42);
    *obj = &tmp;
}
int main() {
    Obj* obj;
    func(&obj);
    std::cout << obj->x << std::endl;
}
```

???

Que provoque ce code ?

---

# üë£ üî´

```bash
$ g++ main.cpp && ./a.out
> 42
```

```bash
$ g++ main.cpp -O3 && ./a.out
> 0
```

```bash
$ clang++ main.cpp -O3 && ./a.out
> -1651023112
```

???

Meme pas le bon gout de provoquer un segfault !

---

# Rust üòÖ

```rust
fn main() {
    let x: &i32;
    {
        let y = 100;
        x = &y;
    }
    println!("Hello, {}", *x);
}
```

---

# Sauv√© par le compilateur !

```
error[E0597]: `y` does not live long enough
 --> src/main.rs:5:14
  |
5 |         x = &y;
  |              ^ borrowed value does not live long enough
6 |     }
  |     - `y` dropped here while still borrowed
7 |     println!("Hello, {}", *x);
8 | }
  | - borrowed value needs to live until here

error: aborting due to previous error

For more information about this error, try
`rustc --explain E0597`.
```

---

class: middle, center

# Etape 1

### Compiler Rust vers wasm

---

# Installer Rust

### A ne faire qu'une seule fois ‚ö†Ô∏è


```
curl https://sh.rustup.rs -sSf | sh
export PATH=$HOME/.cargo/bin:$PATH
rustup toolchain install nightly
rustup target add wasm32-unknown-unknown --toolchain nightly
```

???

Attention en t√©l√©chargeant et streamant dans sh !

---

# Commencer un projet

Initialiser le projet :

```
cargo +nightly new --lib example
```

Ajouter dans le fichier `Cargo.toml` :

```
[lib]
crate-type = ["cdylib"]
```

Build vers WebAssembly :

```
cd example
cargo +nightly build --target wasm32-unknown-unknown \
    --release
```

---

### [Simple Rust example](./example/index.html) - Rust

```rust
// A function that's defined in JS.
extern {
    fn console_log(x: u32);
}

// A function that's exported to JS.
#[no_mangle]
pub extern fn add_one(a: u32) -> u32 {
    unsafe { console_log(a) };
    a + 1
}
```

---

### [Simple Rust example](./example/index.html) - JS

```js
// ‚ö†Ô∏è mimetype application/wasm
const response = fetch('example.wasm');
(async function() {
    let { instance } = (
        await WebAssembly.instantiateStreaming(response, {
            env: {
                // Define the imported JS function.
                console_log(x) {
                    console.log(x);
                }
            }
        })
    );
    alert(instance.add_one(41));
    // alert(42), console.log(41)
})();
```

---

# Probl√®mes de cette approche

### Etape de *build* pas int√©gr√©e
### N√©cessit√© de toucher aux APIs WebAssembly
### Interactions avec des APIs du Web depuis le langage source ?
### Interop√©rabilit√© avec des types plus complexes (source ou Web) ?

???

Wasm fournit beaucoup d'abstractions bas niveau (table de fonctions, fonctions,
bloc de m√©moire lin√©aire), mais ne permet pas d'utiliser des types plus haut
niveau : cha√Æne de caract√®res, bool√©ens, ou types d√©finis par les devs.

Possibilit√© d'appeler des fonctions JS depuis Wasm et inversement.

N√©cessit√© de rajouter plein de d√©clarations pour pouvoir utiliser des APIs Web
depuis le langage source, pour partager des types entre les deux langages, etc.

---

class: bigger

# Exemple : cha√Ænes de caract√®res

### De JS √† Rust

- transformer cette cha√Æne dans sa repr√©sentation m√©moire *en Rust*
- mettre cette repr√©sentation en m√©moire wasm
- c√¥t√© Rust, construire une cha√Æne depuis cette repr√©sentation

--

### De Rust √† JS

Les m√™mes √©tapes... en sens inverse !

???

- pas facile pour commencer √† d√©velopper

Des probl√®mes inh√©rents √† tous les langages

- surcout memoire : la chaine est repr√©sent√©e plusieurs fois.
- surcout temps : encodage / d√©codage de la cha√Æne.
- augmente l'activit√© du GC c√¥t√© JS.

---

class: center, middle

# Etape 2 : des g√©n√©rateurs de *bindings*

### Et si des outils faisaient le travail pour nous ?

---

# Cr√©er des projets

Une seule fois :

```bash
# wasm-pack to simplify build process
cargo install wasm-pack
# cargo-generate for project templates
cargo install cargo-generate
# template for Web counterpart
npm install -g create-wasm-app
```

Pour chaque projet :

```bash
# init Rust project from rust-wasm template
cargo generate \
    --git https://github.com/rustwasm/wasm-pack-template
cd example-project
wasm-pack build # installs deps + initial build
npm init wasm-app www # init frontend from wasm template
(cd www && npm install)
```

---

# Build & bundle

Recompiler :

```bash
wasm-pack build
```

D√©ployer le front en temps r√©el avec `webpack-dev-server` (dans `www`) :

```bash
cd www && npm start
```

---

# [A simple example](./example-generate/www/dist)

```rust
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    fn alert(s: &str);
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn console_log(x: u32);
}

#[wasm_bindgen]
pub fn greet(s: &str) {
    console_log(42);
    alert(&format!("Hello, {}!", s));
}
```

```js
import * as rust from "../pkg/example-project"; // js file
rust.greet("world");
```

---

# D√©clarer un type

```rust
#[wasm_bindgen]
pub struct HelloFactory {
    name: String
}
#[wasm_bindgen]
impl HelloFactory {
    pub fn new(name: String) -> HelloFactory {
        HelloFactory { name: name }
    }
    pub fn say_hello(&self) {
        alert(&format!("Hello, {}", self.name));
    }
}
```

```js
import('./project.js').then(project => {
    let factory = project.HelloFactory.new("Benjamin");
    factory.say_hello();
    factory.free();
});
```

---

class: bigger

# Comment √ßa marche ?

### attribut `#[wasm_bindgen]` g√©n√®re du code Rust et une *user section* wasm
### `wasm-bindgen` g√©n√®re des bindings JS en lisant la *user section*
### la *user section* est retir√©e du wasm final

???

wasm-bindgen g√©n√®re du code Rust et du code JS pour interagir plus facilement
entre les deux mondes.

- le code wasm r√©sultant contient un tout petit allocateur de m√©moire pour
pouvoir passer des param√®tres (via la m√©moire wasm).
- et des wrappers Rust pour reconstruire les arguments pass√©s depuis la m√©moire
ou les valeurs retourn√©es vers la m√©moire par les fonctions.
- le code JS contient des wrappers pour simplifier le passage de valeurs dans
l'autre sens √©galement.

Au final :
- 1 fichier JS qui propose une interface similaire √† celle du code Rust
- 1 fichier wasm qui sera import√© par le module JS

Remarque : tout ce qui devait √™tre fait √† la main est bel et bien effectu√© par
les wrappers ; il y a donc un co√ªt suppl√©mentaire pour passer la barri√®re de la
FFI (dans notre exemple, m√©moire : duplication des cha√Ænes ; CPU :
encodage/d√©codage).

---

class: middle, center, bigger

# [D√©mo compl√®te : un correcteur de typos](./levenshtein/dist/index.html)

\#DeepLearning \#CS301

---

class: bigger

# Etapes suivantes

1. des bindings pour les APIs JS et du Web

 - [js-sys](https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys)
 - [web-sys](https://github.com/rustwasm/wasm-bindgen/tree/master/crates/web-sys)

???

g√©n√©r√©s √† la main (pour JS), automatiquement depuis WebIDL (pour le Web)

--
2. des frameworks Web

  - [yew](https://github.com/DenisKolodin/yew)

---

class: bigger

# Exemple : la JVM & [TeaVM](http://teavm.org/)

### Compiler le bytecode Java + runtime

???

Plein d'autres mani√®res de faire :
- transpiler depuis Java,
- CheerpJ, autre exemple qui compile directement le bytecode,
- portage JVM (e.g. Doppio) : n'importe quel bytecode JVM, mais plus grande complexit√© ou
performance moindre (n√©cessit√© d'optimisations dynamiques aka JIT).

Support exp√©rimental de wasm dans TeaVM.

Plein d'autres projets pour porter vers le Web : JWebAssembly, Kotlin Native,
Bytecoder, GWT...

--
### sous-ensemble de fonctionnalit√©s

???

Pas de GC, pas de r√©flectivit√© (runtime type information), d'autres
limitations.

--
### des annotations Java pour importer et exporter

--
### un framework Java pour interagir avec le Web : [Flavour](http://teavm.org/docs/flavour/templates.html)

---

# TeaVM wasm

```java
package org.teavm;

import org.teavm.interop.Import;
import org.teavm.interop.Export;

public class Client {
    @Import(name="get_rhs")
    private static native int get_rhs();

    @Export(name="add")
    public static int add(int a) {
        return a + get_rhs();
    }

    public static void main(String[] args) {
    }
}
```

---

# Et le futur ?

--

### garbage collector

--

### host bindings

--

### threads

--

### exception handling

--

### SIMD

---

class: center, middle

# En r√©sum√©

### plus rapide √† charger
### plus rapide √† l'ex√©cution

--

### *B.Y.O.L* (Bring Your Own Langage)

--

### Cr√©er des sites Web avec votre langage

---

class: middle, center

# Exp√©rimentez !

### slides : [bnjbvr.github.io/slides/2018/wasm-paris](https://bnjbvr.github.io/slides/2018/wasm-paris)
### Rust+Wasm : [github.com/rustwasm](https://github.com/rustwasm/)
### WebAssembly : [webassembly.org](https://webassembly.org/)
### Infos : [@WasmWeekly](https://twitter.com/WasmWeekly)
### [@bnjbvr](https://twitter.com/bnjbvr)

    </textarea>
    <script src="remark.js">
    </script>
    <script>
var slideshow = remark.create({
    highlightLanguage: "javascript",
    highlightLines: true,
    countIncrementalSlides: false
});
    </script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
  </body>
</html>
